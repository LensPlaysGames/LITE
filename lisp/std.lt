;; Include this file in LITE by passing the path to this file as a command-line argument.

;; More easily access nested pair elements.
(define caar
    (lambda (x)
      "Get the left side of the left side of the given pair."
      (car (car x))
      ))
(define cadr
    (lambda (x)
      "Get the left side of the right side of the given pair.

Most often used to get the next element in a list."
      (car (cdr x))
      ))

(define abs
    (lambda (x)
      "Return X's distance from zero, which is always positive,
also known as the absolute value."
      (if (< x 0)
          (* x -1)
          x)
      ))

;; LIST FOLDING FUNCTIONS
;; https://en.wikipedia.org/wiki/Fold_(higher-order_function)

;; Fold List Left
(define foldl
    (lambda (some-function initial-value some-list)
      "Apply SOME-FUNCTION to each element within SOME-LIST in reverse order,
as well as place INITIAL-VALUE at the beginning of SOME-LIST (end of reversed list)."
      (if some-list
          (foldl some-function
                 (some-function initial-value (car some-list))
                 (cdr some-list))
          initial-value)
      ))

;; Fold List Right
(define foldr
    (lambda (some-function initial-value some-list)
      "Applies SOME-FUNCTION to each element within SOME-LIST,
as well as places INITIAL-VALUE at the end of SOME-LIST."
      (if some-list
          (some-function (car some-list)
                         (foldr some-function
                                initial-value
                                (cdr some-list)))
          initial-value)
      ))

;; LIST UTILITY FUNCTIONS

(define list
    (lambda items
      "Create a list from any amount of given ITEMS."
      (foldr cons nil items)
      ))

(define list-reverse
    (lambda items
      "Create a list from any amount of given ITEMS in reverse order."
      (foldl (lambda (a b) (cons b a)) nil items)
      ))

(define reverse-list
    (lambda (list)
      "Reverse a given LIST."
      (foldl (lambda (a b) (cons b a)) nil list)
      ))

;; Append list B to list A.
(define append
    (lambda (a b)
      "Append list A to list B"
      (foldr cons b a)))

;; MAPPING

(define unary-map
    (lambda (some-function some-list)
      (foldr (lambda (x rest) (cons (some-function x) rest))
             nil
             some-list)))

(define map
    (lambda (some-function . arg-lists)
      (if (car arg-lists)
          (cons (apply some-function (unary-map car arg-lists))
                (apply map (cons some-function (unary-map cdr arg-lists))))
          nil)))


;; QUASIQUOTATION

(macro quasiquote (x)
       "Quote the given expression, but parse 'UNQUOTE' and 'UNQUOTE-SPLICING'."
       (if (pairp x)
           (if (eq (car x) 'unquote)
               (cadr x)
               (if (pairp (car x))
                   (if (eq (caar x) 'unquote-splicing)
                       (list 'append
                             (cadr (car x))
                             (list 'quasiquote (cdr x)))
                       (list 'cons
                             (list 'quasiquote (car x))
                             (list 'quasiquote (cdr x))))
                   (list 'cons
                         (list 'quasiquote (car x))
                         (list 'quasiquote (cdr x)))))
           (list 'quote x)))

(macro let (defs . body)
       "Bind the given symbols definitions while evaluating body."
       `((lambda ,(map car defs) "" ,@body)
         ,@(map cadr defs)))

;; ARITHMETIC & LOGIC

;; Redefine '+' operator to handle any amount of integer arguments.
(define +
    (let ((old+ +))
      (lambda ints (foldl old+ 0 ints))
      ))

;; Redefine '*' operator to handle any amount of integer arguments.
(define *
    (let ((old* *))
      (lambda ints (foldl old* 1 ints))
      ))
