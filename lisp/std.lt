;; Include this file in LITE by passing the path to this file as a command-line argument.

;; More easily access nested pair elements.
(define caar
    (lambda (x)
      (car (car x)))
  "Get the left side of the left side of the given pair.")
(define cadr
    (lambda (x)
      (car (cdr x)))
  "Get the left side of the right side of the given pair.

Most often used to get the next element in a list.")

;; LIST FOLDING FUNCTIONS
;; https://en.wikipedia.org/wiki/Fold_(higher-order_function)

;; Fold List Left
(define foldl
    (lambda (some-function initial-value some-list)
      (if some-list
          (foldl some-function
                 (some-function initial-value (car some-list))
                 (cdr some-list))
          initial-value))
  "Apply SOME-FUNCTION to each element within SOME-LIST in reverse order,
as well as place INITIAL-VALUE at the beginning of SOME-LIST.")

;; Fold List Right
(define foldr
    (lambda (some-function initial-value some-list)
      (if some-list
          (some-function (car some-list)
                         (foldr some-function
                                initial-value
                                (cdr some-list)))
          initial-value))
  "Applies SOME-FUNCTION to each element within SOME-LIST,
as well as places INITIAL-VALUE at the end of SOME-LIST.")

;; LIST UTILITY FUNCTIONS

(define list
    (lambda items
      (foldr cons nil items))
  "Create a list from any amount of given ITEMS.")

(define list-reverse
    (lambda items
      (foldl (lambda (a b) (cons b a)) nil items))
  "Create a list from any amount of given ITEMS in reverse order.")

(define reverse-list
    (lambda (list)
      (foldl (lambda (a b) (cons b a)) nil list))
  "Reverse a given LIST.")

;; Append list B to list A.
(define append
    (lambda (a b)
      (foldr cons b a))
  "Append list A to list B")

;; MAPPING

(define unary-map
    (lambda (some-function some-list)
      (foldr (lambda (x rest) (cons (some-function x) rest))
             nil
             some-list)))

(define map
    (lambda (some-function . arg-lists)
      (if (car arg-lists)
          (cons (apply some-function (unary-map car arg-lists))
                (apply map (cons some-function (unary-map cdr arg-lists))))
          nil)))

;; QUASIQUOTATION

(macro quasiquote (x)
       "Quote the given expression, but parse 'UNQUOTE' and 'UNQUOTE-SPLICING'."
       (if (pairp x)
           (if (eq (car x) 'unquote)
               (cadr x)
               (if (pairp (car x))
                   (if (eq (caar x) 'unquote-splicing)
                       (list 'append
                             (cadr (car x))
                             (list 'quasiquote (cdr x)))
                       (list 'cons
                             (list 'quasiquote (car x))
                             (list 'quasiquote (cdr x))))
                   (list 'cons
                         (list 'quasiquote (car x))
                         (list 'quasiquote (cdr x)))))
           (list 'quote x)))

;; Make UNQUOTE and UNQUOTE-SPLICING cause an error when used outside of quasiquote
(macro unquote _
       "Disallow UNQUOTE outside of QUASIQUOTE"
       (print "UNQUOTE should not be used outside of QUASIQUOTE."))
(macro unquote-splicing _
       "Disallow UNQUOTE-SPLICING outside of QUASIQUOTE"
       (print "UNQUOTE-SPLICING should not be used outside of QUASIQUOTE."))

;; HELPER MACROS

;; This enforces a docstring when defining a named lambda.
(macro defun (name args docstring . body)
       "Define a named lambda function with a given docstring."
       `(define ,name (lambda ,args ,@body) ,docstring))

;; This copies `MACRO` exactly, it's purely visual.
(macro defmacro (macro-name args docstring . body)
       "Define a macro."
       `(macro ,macro-name ,args ,docstring ,@body))

(macro let (defs . body)
       "Bind the given symbols to the given values while evaluating body."
       `((lambda ,(map car defs) ,@body)
         ,@(map cadr defs)))

;; ARITHMETIC & LOGIC

;; Redefine '+' operator to handle any amount of integer arguments.
(define +
    (let ((old+ +))
      (lambda ints (foldl old+ 0 ints)))
  "Return the sum of any amount of integer arguments.")

;; Redefine '*' operator to handle any amount of integer arguments.
(define *
    (let ((old* *))
      (lambda ints (foldl old* 1 ints)))
  "Return the product of any amount of integer arguments.")

(define abs
    (lambda (x)
      (if (< x 0)
          (* x -1)
          x))
  "Return X's distance from zero, which is always positive,
also known as the absolute value.")

(macro when (condition . body)
       "Evaluate BODY iff CONDITION evaluates to any non-nil value."
       `(if ,condition ,@body nil))

(macro unless (condition . body)
       "Evaluate BODY iff CONDITION evaluates to nil."
       `(if (! ,condition) ,@body nil))

;; ASSOCIATION LISTS
;; also known as ALISTS

(macro alist-set (alist key value)
       "Return ALIST with KEY associated to VALUE."
       `(cons (cons ,key ,value) ,alist))

(define alist-get
    (lambda (alist key)
      (if (eq key (car (car alist)))
          ;;then
          (cdr (car alist))
          ;;else
          (if (cdr alist)
              (alist-get (cdr alist) key)
              nil)))
  "Get the value associated with KEY in ALIST, or nil if not found.")

;; BUFFERS

(defun buffer-prev-line (buffer)
  "Get the line before the current line, if possible."
  (let ((newline-seek-substring "
")
        (original-point (buffer-point current-buffer)))
    (if (= (buffer-seek-byte current-buffer newline-seek-substring -1) 0)
        (buffer-set-point current-buffer 0)
        nil)
    (let ((output (buffer-current-line current-buffer)))
      (buffer-set-point current-buffer original-point)
      output)))

(defun buffer-next-line (buffer)
  "Get the line after the current line, if possible."
  (let ((newline-seek-substring "
")
        (original-point (buffer-point current-buffer)))
    (buffer-seek-byte current-buffer newline-seek-substring 1)
    (let ((output (buffer-current-line current-buffer)))
      (buffer-set-point current-buffer original-point)
      output)))

;; Navigation

(defun backward-bytes (n)
  "Decrement point of `CURRENT-BUFFER` by N bytes."
  (buffer-set-point current-buffer (- (buffer-point current-buffer) n)))

(defun forward-bytes (n)
  "Increment point of `CURRENT-BUFFER` by N bytes."
  (buffer-set-point current-buffer (+ (buffer-point current-buffer) n)))

(macro backward-byte ()
  "Decrement point of `CURRENT-BUFFER` by one byte."
  (backward-bytes 1))

(macro forward-byte ()
  "Increment point of `CURRENT-BUFFER` by one byte."
  (forward-bytes 1))

(defun beginning-of-line ()
  "Move to the beginning of the current line"
  (let ((newline-string "
"))
    (if (eq (buffer-index current-buffer (buffer-point current-buffer)) newline-string)
        (forward-byte)
        nil)
    (if (= (buffer-seek-byte current-buffer newline-string -1) 0)
        (buffer-set-point current-buffer 0)
        (forward-byte))
    ))

(defun backward-line ()
  "Move backward one line, if possible.

Attempts to keep point column the same."
  (let ((newline-string "
")
        (original-point (buffer-point current-buffer)))
    ;; If point is over a hnewline, move just behind it.
    (if (eq (buffer-index current-buffer (buffer-point current-buffer)) newline-string)
        (backward-byte)
        nil)
    ;; Seek backwards until a newline character, or beginning of buffer.
    (if (= (buffer-seek-byte current-buffer newline-string -1) 0)
        (buffer-set-point current-buffer 0)
        nil)
    (if (= (buffer-point current-buffer) 0)
        ;; then we can not move backwards anymore, we are on first line.
        (buffer-set-point current-buffer original-point)
        ;; Else, calculate offset from original point to current point (column offset).
        (let ((column-index
               (- original-point (buffer-point current-buffer))))
          ;; Seek backwards until a newline character, or beginning of buffer.
          (if (= (buffer-seek-byte current-buffer newline-string -1) 0)
              ;; No newline found, go to beginning of buffer.
              (buffer-set-point current-buffer 0)
              ;; else, newline found, and point is already at it.
              nil)
          (if (= (buffer-point current-buffer) 0)
              (forward-bytes (- column-index 1))
              (forward-bytes column-index))
          ))))

(defun forward-line ()
  "Move forward one line, if possible.

Attempts to keep point column the same."
  ;; I need the offset from beginning of line to point.
  ;; Seek until next newline, then add offset from above iff line is long enough.
  (let ((newline-seek-substring "
")
        (original-point (buffer-point current-buffer)))
    ;; Seek backwards to newline
    ;; if search for newline backwards finds nothing,
    (if (= (buffer-seek-byte current-buffer newline-seek-substring -1) 0)
        ;; then set point to beginning of buffer.
        (buffer-set-point current-buffer 0)
        ;; Otherwise, skip.
        nil
        )
    ;; Calculate offset from original point to beginning of line (column offset).
    (let ((bol-offset (buffer-point current-buffer)))
      (let ((column-index (- original-point bol-offset)))
        ;; if search for newline forwards finds something,
        (if (>= (buffer-seek-byte current-buffer newline-seek-substring 1) 0)
            ;; then move point forward to original column, if possible.
            (if (<= (- column-index 1) (string-length (buffer-next-line current-buffer)))
                (forward-bytes (if (= bol-offset 0) (+ 1 column-index) column-index))
                (forward-byte))
            ;; else nothing was found, restore point to what it was at start of function.
            (buffer-set-point current-buffer original-point))))))

;; MISCELLANEOUS

(macro set-docstring (x string)
  "Set the docstring of X to STRING and return it."
  `(define ,x ,x ,string))

(defun user-says-yes (prompt)
  "Return T iff the user response to PROMPT matches the string 'yes', otherwise return nil.
Useful for ensuring the user would like to do something before doing it."
  ;; TODO: Join "yes" hint on to given prompt.
  ;; TODO: Think about handling capitilization.
  (eq "yes" (read-prompted prompt)))

;; STANDARD KEYBINDINGS

(define keymap
    (alist-set
     keymap "CTRL"
     (alist-set
      (alist-get keymap "CTRL") "a"
      '(beginning-of-line))))

(define keymap
    (alist-set
     keymap "CTRL"
     (alist-set
      (alist-get keymap "CTRL") "b"
      '(backward-byte))))

(define keymap
    (alist-set
     keymap "CTRL"
     (alist-set
      (alist-get keymap "CTRL") "f"
      '(forward-byte))))

(define keymap
    (alist-set
     keymap "CTRL"
     (alist-set
      (alist-get keymap "CTRL") "p"
      '(backward-line))))

(define keymap
    (alist-set
     keymap "CTRL"
     (alist-set
      (alist-get keymap "CTRL") "n"
      '(forward-line))))

(defun save-current-with-msg (msg)
  "Save buffer 'CURRENT-BUFFER' and return MSG."
  (save current-buffer)
  msg)

;; Save current buffer with "CTRL" "s"
(define keymap
    (alist-set
     keymap "CTRL"
     (alist-set
      (alist-get keymap "CTRL") "s"
      '(save-current-with-msg "Saved."))))

;; Evaluate current line with "CTRL" "e"
(define keymap
    (alist-set
     keymap "CTRL"
     (alist-set
      (alist-get keymap "CTRL") "e"
      '(evaluate-string
        (buffer-current-line current-buffer)))))

;; Evaluate zeroeth line with "CTRL" "0"
(define keymap
    (alist-set
     keymap "CTRL"
     (alist-set
      (alist-get keymap "CTRL") "0"
      '(evaluate-string
        (buffer-line current-buffer 0)))))

;; Evaluate current buffer with "LEFT-ALT" "e"
(define keymap
    (alist-set
     keymap "LEFT-ALT"
     (alist-set
      (alist-get keymap "LEFT-ALT") "e"
      '(evaluate-string
        (buffer-string current-buffer)))))

;; Open new file buffer with "LEFT-ALT" "o"
(define keymap
    (alist-set
     keymap "LEFT-ALT"
     (alist-set
      (alist-get keymap "LEFT-ALT") "o"
      '(define current-buffer (open-buffer (read-prompted "filepath: "))))))
