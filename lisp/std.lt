;; Include this file in LITE by passing the path to this file as a command-line argument.

(evaluate-file "lisp/std/basics.lt")
(evaluate-file "lisp/std/maths.lt")
(evaluate-file "lisp/std/lists.lt")
(evaluate-file "lisp/std/structures.lt")

;; UTILITY

(defun keyboard-quit ()
  "Stop all current LISP evaluation.
If you don't know what's happening, messed up, etc. then call this.

Deactivates the mark in the current buffer.
Finishes any prompts/reads.
Quits evaluating all LISP up until the very top level (minimum needed)."
  ;; disable the selection in the current buffer
  (set-mark-activation nil)
  ;; quit any ongoing prompts
  (finish-read)
  ;; stop executing lisp all LITE LISP---this also stops this function,
  ;; so make sure it's at the end.
  (quit-lisp))

(defun list-functions ()
  "List all of the functions currently defined in the environment."
  (dolist (item (car (env)) t)
    (when (closurep (cdr item))
      (print (car item)))))

(defun all-functions ()
  "List all of the functions currently defined in the environment,
and print out their respective docstrings."
  (dolist (item (car (env)) t)
    (when (closurep (cdr item))
      (prins (car item))
      (let ((docstr (docstring (car item) (env))))
        (when docstr
          (prins (string-concat docstr "\\n\\n")))))))

(defmacro save-point-and-mark (buffer . body)
  "Evaluate body, then restore point and mark state of BUFFER.
Return the result of BODY."
  `(let ((original-point           (buffer-point ,buffer))
         (original-mark            (buffer-mark  ,buffer))
         (original-mark-activation (buffer-mark-active ,buffer)))
     (let ((result (progn ,@body)))
       (buffer-set-point           ,buffer original-point)
       (buffer-set-mark            ,buffer original-mark)
       (buffer-set-mark-activation ,buffer original-mark-activation)
       result)))

;; BUFFERS

(defun buffer-prev-line (buffer)
  "Get the line before the current line, if possible."
  (let ((original-point (buffer-point current-buffer)))
    (if (= (buffer-seek-byte current-buffer "\\n" -1) 0)
        (buffer-set-point current-buffer 0)
        nil)
    (let ((output (buffer-current-line current-buffer)))
      (buffer-set-point current-buffer original-point)
      output)))

(defun buffer-next-line (buffer)
  "Get the line after the current line, if possible."
  (let ((original-point (buffer-point current-buffer)))
    (buffer-seek-byte current-buffer "\\n" 1)
    (let ((output (buffer-current-line current-buffer)))
      (buffer-set-point current-buffer original-point)
      output)))

(defun byte-at-point (buffer)
  "Get the byte under the point in BUFFER."
  (buffer-index buffer (buffer-point buffer)))

(defun byte-before-point (buffer)
  "Get the byte just before the point in BUFFER.
If point is zero, get byte at point."
  (let ((point (buffer-point buffer)))
    (if (= point 0)
        (buffer-index buffer 0)
        (buffer-index buffer (- point 1)))))

;; Navigation

(defun backward-bytes (n)
  "Decrement point of `CURRENT-BUFFER` by N bytes."
  (set-point (- (point) n)))

(defun forward-bytes (n)
  "Increment point of `CURRENT-BUFFER` by N bytes."
  (set-point (+ (point) n)))

(defun backward-byte ()
  "Decrement point of `CURRENT-BUFFER` by one byte."
  (backward-bytes 1))

(defun forward-byte ()
  "Increment point of `CURRENT-BUFFER` by one byte."
  (forward-bytes 1))

(defun beginning-of-line ()
  "Move to the beginning of the current line"
  (if (= (seek-byte "\\n" -1) 0)
      (set-point 0)
      (forward-byte))
  current-buffer)

(defun end-of-line ()
  "Move to the end of the current line."
  (if (eq (index (point)) "\\n")
      "\n"
      (when (= (seek-byte "\\n" 1) 0)
        ;; get to end of last line.
        (forward-bytes 999999999999)))
  current-buffer)

;; "input\nstring\nexample\n" ^ = point
;;           ^
;;       |---|                  = column-offset
;; |-----|                      = previous-line-length
(defun backward-line ()
  "Move backward one line, if possible.

Attempts to keep point column the same."
  ;; Calculate column offset and move to end of previous line.
  (let ((column-offset (seek-byte "\\n" -1)))
    ;; 'buffer-seek-byte' returns zero when the given byte was not found.
    ;; The following 'unless' means nothing will happen on the first line.
    (unless (= column-offset 0)
      (let ((previous-line-length-impl (seek-byte "\\n" -1)))
        (let ((previous-line-length
               (if (= 0 previous-line-length-impl)
                   (point)
                   previous-line-length-impl))
              (beginning-of-previous-line
               (if (= previous-line-length-impl 0)
                   0
                   (+ 1 (point)))))
          (set-point beginning-of-previous-line)
          (if (> previous-line-length column-offset)
              (forward-bytes (- column-offset 1))
              (end-of-line))))))
  current-buffer)


(defun current-point-column-offset ()
  "Get the byte offset of the point into the current line."
  (save-point-and-mark
   current-buffer
   (let ((column-offset (seek-byte "\\n" -1)))
     (if (= column-offset 0)
         (+ 1 (point))
         column-offset))))

;; "input\nstring\nexample\n" ^ = point
;;           ^
;;       |---|                  = column-offset
;;               |--------|     = next-line-length
(defun forward-line ()
  "Move forward one line, if possible.

Attempts to keep point column the same."
  (let ((column-offset (current-point-column-offset)))
    ;; Seek forward for next newline, unless already over a newline.
    (unless (eq "\\n" (byte-at-point current-buffer))
      (seek-byte "\\n" 1))
    (let ((next-line-length (seek-byte "\\n" 1)))
      (if (= 0 next-line-length)
          (forward-byte)
          (when (> next-line-length column-offset)
            (backward-bytes (- next-line-length column-offset))))))
  ;; Return current-buffer, just to stay consistent between different
  ;; control flows.
  current-buffer)

(defun search-forward ()
  "Set the point to the beginning of the prompted-for string if it is
found after point in the current buffer."
  (seek-substring (read-prompted "search forward: ") 1))

(defun search-backward ()
  "Set the point to the beginning of the prompted-for string if it is
found behind point in the current buffer."
  (seek-substring (read-prompted "search backward: ") -1))

(set word-delimiters "., \\n(){}[]<>"
     "Each of the bytes within this string is a word delimiter.")

(defun forward-word ()
  "Move forward by one word (separated by 'WORD-DELIMITERS')."
  (seek-past-byte word-delimiters 1)
  (when (= (seek-byte word-delimiters 1) 0)
      (forward-bytes 999999999999)))

(defun backward-word ()
  "Move backward by one word (separated by 'WORD-DELIMITERS')."
  ;; Skip backwards past word delimiters
  (seek-past-byte word-delimiters -1)
  ;; Skip backwards to word delimiter
  (if (= (seek-byte word-delimiters -1) 0)
      (backward-bytes 999999999999)
      ;; If a word was skipped, move forward one byte.
      (forward-byte)))

;; MISCELLANEOUS

(macro set-docstring (x string)
  "Set the docstring of X to STRING and return it."
  `(define ,x ,x ,string))

(defun user-says-yes (prompt)
  "Return T iff the user response to PROMPT matches the string 'yes',
otherwise return nil. Useful for ensuring the user would like to do
something before doing it."
  ;; TODO: Join "yes" hint on to given prompt.
  ;; TODO: Think about handling capitilization.
  (eq "yes" (read-prompted prompt)))

(defun save-current-buffer-with-msg (msg)
  "Save buffer 'CURRENT-BUFFER' and return MSG."
  (save current-buffer)
  msg)

(defun print-environment ()
  "Print the value of the current environment to standard out."
  (let ((env-it (env)))
    (while env-it
      (print (car env-it))
      (define env-it (cdr env-it)))))

(defun evaluate-line ()
  "Evaluate the current line in the current buffer as a LITE LISP expression."
  (evaluate-string (current-line)))

(defun evaluate-first-line ()
  "Evaluate the first line of the current buffer as a LITE LISP expression."
  (evaluate-string (line 0)))

(defun evaluate-prompted ()
  "Evaluate the first line of the current buffer as a LITE LISP expression."
  (evaluate-string (read-prompted "Eval: ")))

(defun activate-mark ()
  "Activate mark in current buffer, and update mark to current point."
  (set-mark-activation t)
  (set-mark (point)))

(defun deactivate-mark ()
  "Deactivate mark in current buffer."
  (set-mark-activation nil))

(defun set-mark-to-point ()
  "Set mark in current buffer to current point."
  (set-mark (point)))

(defun set-or-toggle-mark ()
  "If mark is disabled, activate it. If point is over mark, de-activate mark.
Otherwise, set mark to current point."
  (if (! (mark-active))
      (progn
        (set-mark-to-point)
        (toggle-mark))
      (if (= (point) (mark))
          (toggle-mark)
          (set-mark-to-point))))

(defun insert-lf ()
  "Insert a newline character, but keep point where it is."
  (insert "\\n")
  (set-point (- (point) 1)))

(defun insert-crlf ()
  "Insert a carriage return and a newline character, but keep point
where it is."
  (insert "\\r\\n")
  (set-point (- (point) 2)))

(defun select-current-line ()
  "Mark region of the line the point resides within in the current buffer."
  (beginning-of-line)
  (activate-mark)
  (end-of-line)
  )

(defun copy-current-line ()
  "Copy the current line to the clipboard."
  (save-point-and-mark current-buffer
   (select-current-line)
   (clipboard-copy current-buffer)))

(defun delete-line-past ()
  "Delete up to the next newline after point."
  (save-point-and-mark current-buffer
   (activate-mark)
   (end-of-line)
   (forward-byte)
   (remove (region-length))))

(defun backspace ()
  "Remove the character behind the cursor in the current buffer,
or, if mark is active and a region is selected, remove the entire region."
  (if (buffer-mark-active current-buffer)
      ;; Mark is active, a region is selected.
      (let ((mark (mark))
            (p (point))
            (length (region-length)))
        ;; Don't remove anything if region is of zero-length
        (unless (= length 0)
          ;; Determine if we need to remove forward or backward from point.
          (if (> mark p)
              ;; Mark is past point, remove forward.
              (remove-forward length)
              ;; Point is past mark, remove backward.
              (remove length))))
      ;; Mark isn't active, no region selected---remove a single byte backwards.
      (remove 1)))


(define default-font-size 18
  "The default font size")

(define font-size default-font-size
  "The current font size, if using SIZE-... commands.")

(define font-size-step 2
  "The amount in point size that the current font will be changed by SIZE-... commands.")

(define font-size-min 2
  "The minimum font size that is able to be set from SIZE-... commands.")

(defun size-set (n)
    "Increase the point size of the current font."
    (unless (integerp n)
      (error "size-set MUST be passed an integer."))
    (set font-size (max font-size-min n))
    (change-font-size font-size))

(defun size-reset ()
  "Reset the point size of the current font to default."
  (size-set default-font-size))

(defun size-increase ()
    "Increase the point size of the current font."
    (set font-size (max font-size-min
                        (+ font-size font-size-step)))
    (change-font-size font-size))

(defun size-decrease ()
    "Increase the point size of the current font."
    (set font-size (max font-size-min
                        (- font-size font-size-step)))
    (change-font-size font-size))


;; WINDOW:
;;   (z-level (posx . posy) (sizex . sizey) (scrollx . scrolly) (contents . properties))

;; PROPERTY:
;;   (id offset length (fg.r fg.g fg.b fg.a) (bg.r bg.g bg.b bg.a))


(defun active-window ()
  "Return the active window from window list based on index."
  (elt windows active-window-index))

;; TODO: `set` API for the rest of the members.
;;   NOTE: scroll-up and scroll-down are builtins, but they no longer
;;   have to be.

(defun window-z (window)
  "Return the x position of WINDOW."
  (car window))

(defun set-window-z (window)
  "Set the z level of WINDOW to VALUE."
  (setcar window value))

(defun window-x (window)
  "Return the x position of WINDOW."
  (car (elt window 1)))

(defun set-window-x (window value)
  "Reposition WINDOW at x position VALUE."
  (setcar (elt window 1) value))

(defun window-y (window)
  "Return the y position of WINDOW."
  (cdr (elt window 1)))

(defun set-window-y (window value)
  "Reposition WINDOW at y position VALUE."
  (setcdr (elt window 1) value))

(defun window-w (window)
  "Return the width value in integer percent (0 - 100 inclusive) of WINDOW."
  (car (elt window 2)))

(defun set-window-width (window value)
  "Resize WINDOW width to the given width VALUE."
  (setcar (elt window 2) value))

(defun window-h (window)
  "Return the height value in integer percent (0 - 100 inclusive) of WINDOW."
  (cdr (elt window 2)))

(defun set-window-height (window value)
  "Resize WINDOW height to the given VALUE."
  (setcdr (elt window 2) value))

(defun window-scrollx (window)
  "Return the horizontal scroll value of WINDOW."
  (car (elt window 3)))

(defun set-window-scrollx (window value)
  "Associate the given horizontal scroll VALUE with WINDOW."
  (setcar (elt window 3) value))

(defun window-scrolly (window)
  "Return the vertical scroll value of WINDOW."
  (cdr (elt window 3)))

(defun set-window-scrolly (window value)
  "Associate the given vertical scroll VALUE with WINDOW."
  (setcdr (elt window 3) value))

(defun window-contents (window)
  "Return the contents associated with WINDOW."
  (car (elt window 4)))

(defun set-window-contents (window new-contents)
  "Set the contents associated with WINDOW to NEW-CONTENTS."
  (setcar (elt window 4) new-contents))

(defun window-properties (window)
  "Return the contents associated with WINDOW."
  (cdr (elt window 4)))

(defun set-window-properties (window new-properties)
  "Set the text properties associated with WINDOW to NEW-PROPERTIES."
  (setcdr (elt window 4) new-properties))

(defun set-active-window-buffer (buffer)
  "Set the contents displayed in the active window to the given buffer"
  ;; Reset window contents to given buffer.
  (set-window-contents (active-window) buffer)
  ;; Reset text properties to nil.
  (set-window-properties (active-window) nil))

(defun set-buffer-from-active-window ()
  "Set the contents displayed in the active window to the given buffer"
  ;; TODO: Ensure window is not displaying a string.
  (set current-buffer (window-contents (active-window))))

(defun set-active-window (n)
  "Select a different window in the window list as active."
  (when (and
         (> n -1)
         (< n (length windows)))
    (set active-window-index n)
    (set-buffer-from-active-window)))

(defun cycle-active-window (direction)
  "Change active window to another window in the list, if possible.
Attempt to move backwards"
  (if (or (= direction 0)(> direction 0))
      (unless (set-active-window (+ 1 active-window-index))
        (set-active-window 0))
        (unless (set-active-window (- active-window-index 1))
          (set-active-window (length windows)))))

(defun switch-current-buffer ()
  "Prompt user for a filepath to open a buffer at, and set current-buffer."
  (set current-buffer (open-buffer (read-prompted "filepath: ")))
  (set-active-window-buffer current-buffer))

(defun layout-1 ()
  "One main window."
  (set windows   `((0 (0  . 0) (100 . 100) (0 . 0) (,current-buffer . nil))))
  (set-active-window 0))

(defun layout-vsplit ()
  "Two windows side by side."
  (set windows `((0 (0  . 0) (50  . 100) (0 . 0) (,current-buffer . nil))
                 (0 (50 . 0) (50  . 100) (0 . 0) (,current-buffer . nil))))
  (set-active-window 0))

(defun layout-hsplit ()
  "Two windows top and bottom."
  (set windows `((0 (0 .  0) (100 .  50) (0 . 0) (,current-buffer . nil))
                 (0 (0 . 50) (100 .  50) (0 . 0) (,current-buffer . nil))))
  (set-active-window 0))

(defun layout-maxpane ()
  "Four windows, one in each quadrant."
  (set windows `((0 (40 . 40) (20 . 20) (0 . 0) (,current-buffer . nil))
                 (0 ( 0 .  0) (50 . 50) (0 . 0) (,current-buffer . nil))
                 (0 (50 .  0) (50 . 50) (0 . 0) (,current-buffer . nil))
                 (0 ( 0 . 50) (50 . 50) (0 . 0) (,current-buffer . nil))
                 (0 (50 . 50) (50 . 50) (0 . 0) (,current-buffer . nil))))
  (set-active-window 0))


(layout-1)



(evaluate-file "lisp/std/binds.lt")
