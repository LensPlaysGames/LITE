;; Include this file in LITE by passing the path to this file as a command-line argument.

;; More easily access nested pair elements.
(define caar (lambda (x) (car (car x))))
(define cadr (lambda (x) (car (cdr x))))

;; Absolute Value
;; Return X's distance from zero (always positive).
(define abs
    (lambda (x)
      (if (< x 0)
          (* x -1)
          x)
      ))

;; LIST FOLDING FUNCTIONS
;; https://en.wikipedia.org/wiki/Fold_(higher-order_function)

;; Fold List Left
;; Apply SOME-FUNCTION to each element within SOME-LIST in reverse order,
;; as well as place INITIAL-VALUE at the beginning of SOME-LIST (end of reversed list).
(define foldl
    (lambda (some-function initial-value some-list)
      (if some-list
          (foldl some-function
                 (some-function initial-value (car some-list))
                 (cdr some-list))
          initial-value)
      ))

;; Fold List Right
;; Applies SOME-FUNCTION to each element within SOME-LIST,
;; as well as places INITIAL-VALUE at the end of SOME-LIST.
(define foldr
    (lambda (some-function initial-value some-list)
      (if some-list
          (some-function (car some-list)
                         (foldr some-function
                                initial-value
                                (cdr some-list)))
          initial-value)
      ))

;; LIST UTILITY FUNCTIONS

;; Create a new list from ITEMS.
;; Any amount of arguments may be passed.
(define list
    (lambda items
      (foldr cons nil items)
      ))

;; Create a new list from ITEMS in reverse order.
;; Any amount of arguments may be passed.
(define list-reverse
    (lambda items
      (foldl (lambda (a b) (cons b a)) nil items)
      ))

;; Reverse LIST.
;; Any amount of arguments may be passed.
(define reverse-list
    (lambda (list)
      (foldl (lambda (a b) (cons b a)) nil list)
      ))

;; Append list B to list A.
(define append
    (lambda (a b)
      (foldr cons b a)))

;; MAPPING

(define unary-map
    (lambda (some-function some-list)
      (foldr (lambda (x rest) (cons (some-function x) rest))
             nil
             some-list)))

(define map
    (lambda (some-function . arg-lists)
      (if (car arg-lists)
          (cons (apply some-function (unary-map car arg-lists))
                (apply map (cons some-function (unary-map cdr arg-lists))))
          nil)))


;; QUASIQUOTATION

(macro quasiquote (x)
       (if (pair? x)
           (if (eq? (car x) 'unquote)
               (cadr x)
               (if (pair? (car x))
                   (if (eq? (caar x) 'unquote-splicing)
                       (list 'append
                             (cadr (car x))
                             (list 'quasiquote (cdr x)))
                       (list 'cons
                             (list 'quasiquote (car x))
                             (list 'quasiquote (cdr x))))
                   (list 'cons
                         (list 'quasiquote (car x))
                         (list 'quasiquote (cdr x)))))
           (list 'quote x)))

(macro let (defs . body)
       `((lambda ,(map car defs) ,@body)
         ,@(map cadr defs)))
