;; Include this file in LITE by passing the path to this file as a command-line argument.

(evaluate-file "lisp/std/basics.lt")
(evaluate-file "lisp/std/maths.lt")
(evaluate-file "lisp/std/lists.lt")
(evaluate-file "lisp/std/structures.lt")

;; UTILITY

(defun list-functions ()
  "List all of the functions currently defined in the environment."
  (dolist (item (car (env)) t)
    (when (closurep (cdr item))
      (print (car item)))))

(defun all-functions ()
  "List all of the functions currently defined in the environment,
and print out their respective docstrings."
  (dolist (item (car (env)) t)
    (when (closurep (cdr item))
      (prins (car item))
      (let ((docstr (docstring (car item) (env))))
        (when docstr
          (prins (string-concat docstr "\\n\\n"))
          ))
      )))

;; BUFFERS

(defun buffer-prev-line (buffer)
  "Get the line before the current line, if possible."
  (let ((original-point (buffer-point current-buffer)))
    (if (= (buffer-seek-byte current-buffer "\\n" -1) 0)
        (buffer-set-point current-buffer 0)
        nil)
    (let ((output (buffer-current-line current-buffer)))
      (buffer-set-point current-buffer original-point)
      output)))

(defun buffer-next-line (buffer)
  "Get the line after the current line, if possible."
  (let ((original-point (buffer-point current-buffer)))
    (buffer-seek-byte current-buffer "\\n" 1)
    (let ((output (buffer-current-line current-buffer)))
      (buffer-set-point current-buffer original-point)
      output)))

;; Navigation

(defun backward-bytes (n)
  "Decrement point of `CURRENT-BUFFER` by N bytes."
  (buffer-set-point current-buffer (- (buffer-point current-buffer) n)))

(defun forward-bytes (n)
  "Increment point of `CURRENT-BUFFER` by N bytes."
  (buffer-set-point current-buffer (+ (buffer-point current-buffer) n)))

(defun backward-byte ()
  "Decrement point of `CURRENT-BUFFER` by one byte."
  (backward-bytes 1))

(defun forward-byte ()
  "Increment point of `CURRENT-BUFFER` by one byte."
  (forward-bytes 1))

(defun beginning-of-line ()
  "Move to the beginning of the current line"
  (if (= (buffer-seek-byte current-buffer "\\n" -1) 0)
      (buffer-set-point current-buffer 0)
      (forward-byte)))

(defun end-of-line ()
  "Move to the end of the current line."
  (if (eq (buffer-index current-buffer (buffer-point current-buffer)) "\\n")
      "\n"
      (if (= (buffer-seek-byte current-buffer "\\n" 1) 0)
          (forward-bytes 999999999999) ;; get to end of last line.
          "End of line.")))

(defun backward-line ()
  "Move backward one line, if possible.

Attempts to keep point column the same."
  ;; Calculate column offset and move to end of previous line.
  (let ((column-offset (buffer-seek-byte current-buffer "\\n" -1)))
    (when (eq (buffer-index current-buffer (buffer-point current-buffer)) "\\r")
      (forward-byte))
    ;; If on the first line, do nothing.
    (unless (= column-offset 0)
      (let ((distance-from-end-to-column (+ (- (string-length (buffer-current-line current-buffer)) column-offset) 1)))
        (if (> distance-from-end-to-column 0)
            (backward-bytes distance-from-end-to-column)
            current-buffer)))))

(defun forward-line ()
  "Move forward one line, if possible.

Attempts to keep point column the same."
  (let ((original-point (buffer-point current-buffer)))
    ;; Seek backwards to newline and keep track of originating column.
    (let ((column-offset
           (let ((column-offset-impl (buffer-seek-byte current-buffer "\\n" -1)))
             ;; If cursor is on the first line of the buffer,
             (if (= column-offset-impl 0)
                 ;; then column offset is one above cursor byte offset.
                 (progn
                   (when (eq (buffer-index current-buffer (buffer-point current-buffer)) "\\n")
                     (backward-byte))
                   (+ 1 original-point))
                 ;; otherwise, return bytes moved.
                 column-offset-impl))))
      ;; Seek forward to next newline.
      (buffer-seek-byte current-buffer "\\n" 1)
      ;; if next line has space to navigate to originating column,
      (if (<= column-offset (string-length (buffer-next-line current-buffer)))
          ;; then navigate to the originating column.
          (forward-bytes column-offset)
          ;; Otherwise, seek to the next newline.
          (if (= (buffer-seek-byte current-buffer "\\n" 1) 0)
              ;; If no newline is found, move to end of buffer.
              (forward-bytes 999999999999)
              current-buffer)))))

(defun search-forward ()
  "Set the point to the beginning of the prompted-for string if it is found in current buffer."
  (buffer-seek-substring current-buffer (read-prompted "search forward: ") 1))

(defun search-backward ()
  "Set the point to the beginning of the prompted-for string if it is found in current buffer."
  (buffer-seek-substring current-buffer (read-prompted "search forward: ") -1))

(set word-delimiters "., \\n(){}[]<>"
     "Each of the bytes within this string is a word delimiter.")

(defun forward-word ()
  "Move forward by one word (separated by 'WORD-DELIMITERS')."
  (buffer-seek-past-byte current-buffer word-delimiters 1)
  (when (= (buffer-seek-byte current-buffer word-delimiters 1) 0)
      (forward-bytes 999999999999)))

(defun backward-word ()
  "Move backward by one word (separated by 'WORD-DELIMITERS')."
  ;; Skip backwards past word delimiters
  (buffer-seek-past-byte current-buffer word-delimiters -1)
  ;; Skip backwards to word delimiter
  (if (= (buffer-seek-byte current-buffer word-delimiters -1) 0)
      (backward-bytes 999999999999)
      ;; If a word was skipped, move forward one byte.
      (forward-byte)))

;; MISCELLANEOUS

(macro set-docstring (x string)
  "Set the docstring of X to STRING and return it."
  `(define ,x ,x ,string))

(defun user-says-yes (prompt)
  "Return T iff the user response to PROMPT matches the string 'yes', otherwise return nil.
Useful for ensuring the user would like to do something before doing it."
  ;; TODO: Join "yes" hint on to given prompt.
  ;; TODO: Think about handling capitilization.
  (eq "yes" (read-prompted prompt)))

(defun save-current-buffer-with-msg (msg)
  "Save buffer 'CURRENT-BUFFER' and return MSG."
  (save current-buffer)
  msg)

(defun print-environment ()
  "Print the value of the current environment to standard out."
  (let ((env-it (env)))
    (while env-it
      (print (car env-it))
      (define env-it (cdr env-it)))))

(defun switch-current-buffer ()
  "Prompt user for a filepath to open a buffer at, and set current-buffer."
  (set current-buffer (open-buffer (read-prompted "filepath: "))))

(defun evaluate-line ()
  "Evaluate the current line in the current buffer as a LITE LISP expression."
  (evaluate-string (buffer-current-line current-buffer)))

(defun evaluate-first-line ()
  "Evaluate the first line of the current buffer as a LITE LISP expression."
  (evaluate-string (buffer-line current-buffer 0)))

(defun evaluate-prompted ()
  "Evaluate the first line of the current buffer as a LITE LISP expression."
  (evaluate-string (read-prompted "Eval: ")))

(defun set-or-toggle-mark ()
  "If mark is disabled, activate it. If point is over mark, de-activate mark.
Otherwise, set mark to current point."
  (if (! (buffer-mark-active current-buffer))
      (progn
        (buffer-set-mark current-buffer (buffer-point current-buffer))
        (buffer-toggle-mark current-buffer))
      (if (= (buffer-point current-buffer) (buffer-mark current-buffer))
          (buffer-toggle-mark current-buffer)
          (buffer-set-mark current-buffer (buffer-point current-buffer)))))

(defun insert-lf ()
  "Insert a newline character, but keep point where it is."
  (buffer-insert current-buffer "\\n")
  (buffer-set-point current-buffer (- (buffer-point current-buffer) 1)))

(defun insert-crlf ()
  "Insert a carriage return and a newline character, but keep point
where it is."
  (buffer-insert current-buffer "\\r\\n")
  (buffer-set-point current-buffer (- (buffer-point current-buffer) 2)))

(defun select-current-line ()
  "Mark region of the line the point resides within in the current buffer."
  (beginning-of-line)
  (set-or-toggle-mark)
  (end-of-line)
  )

(defun copy-current-line ()
  "Copy the current line to the clipboard."
  (let ((original-point (buffer-point current-buffer))
        (original-mark (buffer-mark current-buffer)))
    (select-current-line)
    (clipboard-copy current-buffer)
    (buffer-toggle-mark current-buffer)
    (buffer-set-point current-buffer original-point)
    (buffer-set-mark current-buffer original-mark)))


(evaluate-file "lisp/std/binds.lt")
