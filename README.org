#+title: LISP INTERPRETER AND TEXT EDITOR
#+author: Rylan Lens Kellogg
#+description: LITE is a lisp interpreter and text editor built in C.
#+created: <2022-05-26 Thu>
#+options: toc:nil

* LITE

LITE may mean anything that abbreviates the letters;
listed here are a few that are especially significant.

- LISP INTERPRETER and TEXT EDITOR
- LITE IS TOTALLY EMACS
- LISP IMBUED with TONS of ECCENTRICITIES

The goal of LITE is to create a modern, cross-platform tool
for text editing and general scripting that is *easy to port*.

Initially, development followed [[https://www.lwh.jp/lisp/][this LISP interpreter tutorial]].
If you are wanting to do this for yourself, and make your own LISP (interpreter),
there are many tutorials out there: pick one that makes sense to you.

** Usage

Enter the REPL by running the built executable from a terminal.

Any arguments given are treated as source files,
and are loaded into the environment before entring the REPL.

** Building

[[https://cmake.org/][CMake]] is used as the cross-platform build system.

First, generate a local build tree:
#+begin_src sh
  cmake -G <GENERATOR> -S . -B bld -DCMAKE_BUILD_TYPE=Release
#+end_src

Replace =<GENERATOR>= with your choice of build system,
being GNU Make, Ninja, or otherwise. Don't include the angled brackets.
To see a list of available generators, invoke CMake
with just the ~-G~ option, no other arguments.

Once the build tree is generated, invoke it to generate an executable.
#+begin_src sh
  cmake --build bld
#+end_src

The ~bin~ subdirectory should now be populated with the LITE executable.

* LITE LISP
LITE LISP is the language that LITE interprets.

** Types

Everything in LISP is an object called an ~Atom~.
An Atom has a type, and a value.

Here are the different types an Atom may have in LITE LISP:
- Nil -- This is the definition of false, nothing, etc.
- Pair -- A recursive pair, containing a left-hand Atom and a right-hand Atom.

  A pair has special terminology for the two sides; the left is
  referred to as ~car~, while the right is referred to as ~cdr~.

  A list is a pair with a value on the left,
  and another pair, or nil, on the right.

- Symbol -- A string that may be bound in the environment.
- Integer -- An integer number.
- BuiltIn -- A function implemented in the source code that is called from LISP.
- Closure -- A function that is able to be called from LISP.
- Macro -- A function whose body returns an expression that is then evaluated.

** Variables

Variables are stored globally, and are stored in the /environment/.
The environment is like a key-value dictionary, where the keys are
some symbol (a string), and the values are LISP objects (an 'Atom').

To create a new variable, use the ~DEFINE~ operator.
#+begin_src lisp
  (define new-variable 42)
#+end_src

~new-variable~ is now a symbol bound in the environment.
It has an integer value of =42=.

You can see the value a symbol has by evaluating it.
#+begin_src lisp
  new-variable
#+end_src
The output will be =42=, as the symbol was evaluated.
Evaluating a symbol means it is replaced with
the corresponding value from the environment.

Sometimes, it is useful to *not* evaluate a variable.
This can be done using the ~QUOTE~ operator.
#+begin_src lisp
  (quote new-variable)
#+end_src

As this is a very common necessity in LISP, there is
a special short-hand for it: a preceding single-quote.
This short-hand means the following to be equivalent to the ~QUOTE~ just above.
#+begin_src lisp
  'new-variable
#+end_src

** Lambda

If you are not familiar, a lambda is just a function with no name.

Currently, lambdas have the following syntax:
#+begin_src lisp
  (lambda (ARGUMENT ...) BODY-EXPRESSION)
#+end_src

There is also support for variadic arguments using an /improper list/.
Improper lists have not ~NIL~ at the end, but a value.

The syntax for an improper list is as follows:
: (1 2 3 . 4)

In the context of a lambda, here is how to define
a function with a varying number of arguments.
#+begin_src lisp
  (lambda (argument . the-rest) BODY-EXPRESSION)
#+end_src

After all fixed arguments are given, the rest are
converted to a list and passed to the function.

As a real-world example, here is a factorial implementation in LITE LISP:
#+begin_src lisp
  (define fact (lambda (x) (if (= x 0) 1 (* x (fact (- x 1))))))
#+end_src

** Comments

Comments are delimited with the ';' character, per line.

#+begin_src lisp
  ;; This is a comment
  ;; It begins with a ';', and ends upon encountering a newline.
  (define length 42069) ; They work at the end of lines, as well.
#+end_src

** Macros

A macro may be created with the ~MACRO~ operator.
A macro is like a lambda, except it will return the result of evaluating
it's return value, rather than it's return value being the result.

A very simple example:
#+begin_src lisp
  (macro my-quote (x) (cons 'quote (cons x nil)))
#+end_src

As you can see, this builds the Atom: ~(QUOTE . (X . NIL))~
(which is equivalent visually to ~(QUOTE X)~). This will then
be evaluated, and the return value will be the ~X~ symbol.

This system is very powerful, as it allows the interpreted LISP
commands being run to be built up in the LISP environment itself.

** Misc

Currently, functions are stored in the symbol table with the following syntax:
: (ENVIRONMENT (ARGUMENT ...) BODY-EXPRESSION)

I think I'd like to squeeze docstrings in there.
