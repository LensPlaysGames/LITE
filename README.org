#+title: LISP INTERPRETER AND TEXT EDITOR
#+author: Rylan Lens Kellogg
#+description: LITE is a lisp interpreter and text editor built in C.
#+created: <2022-05-26 Thu>
#+options: toc:nil

** LITE

LITE may mean anything that abbreviates the letters;
listed here are a few that are especially significant.

- LISP INTERPRETER and TEXT EDITOR
- LITE IS TOTALLY EMACS
- LISP IMBUED with TONS of ECCENTRICITIES

The goal of LITE is to create a modern, cross-platform tool
for text editing and general scripting that is *easy to port*.

Initially, development followed [[https://www.lwh.jp/lisp/][this LISP interpreter tutorial]].
If you are wanting to do this for yourself, and make your own LISP (interpreter),
there are many tutorials out there: pick one that makes sense to you.

*** Usage

If using LITE GFX, simply launch the executable and a window should appear.
Otherwise, enter the REPL by running the executable from a terminal.

Any arguments given are treated as source files, and
are loaded into the environment before entring the REPL.

It is recommended to include the standard LITE LISP
library at ~std.lt~ in the ~lisp~ subdirectory.
: bin/LITE lisp/std.lt

Or on Windows:
: .\bin\LITE.exe .\lisp\std.lt

*** Building

[[https://cmake.org/][CMake]] is used as the cross-platform build system.

First, generate a local build tree:
#+begin_src sh
  cmake -G <GENERATOR> -S . -B bld -DCMAKE_BUILD_TYPE=Release
#+end_src

Replace =<GENERATOR>= with your choice of build system,
being Unix Makefiles, Ninja, or otherwise. Don't include the angled brackets.
To see a list of available generators, invoke CMake
with just the ~-G~ option, no other arguments.

Once the build tree is generated, invoke it to generate an executable.
#+begin_src sh
  cmake --build bld
#+end_src

The ~bin~ subdirectory should now be populated with the LITE executable.

** LITE LISP
LITE LISP is the language that LITE interprets.

*** Types

Everything in LISP is an object called an ~Atom~.
An Atom has a type, a value, and a docstring.

Here are the different types an Atom may have in LITE LISP:
- Nil -- This is the definition of false, nothing, etc.
- Pair -- A recursive pair, containing a left-hand Atom and a right-hand Atom.

  A pair has special terminology for the two sides; the left is
  referred to as ~car~, while the right is referred to as ~cdr~.

  A list is a pair with a value on the left,
  and another pair, or nil, on the right.

- Symbol -- A string that may be bound in the environment.
- Integer -- An integer number.
- BuiltIn -- A function implemented in the source code that is called from LISP.
- Closure -- A function that is able to be called from LISP; a lambda.
- Macro -- A function whose body returns an expression that is then evaluated.
- String -- A sequence of bytes, usually denoting human readable text.

More about docstrings in the section about variables.

*** Variables

Variables are stored globally, and are stored in the /environment/.
The environment is like a key-value dictionary, where the keys are
some symbol (a string), and the values are LISP objects (an 'Atom').

To create a new variable, use the ~DEFINE~ operator.
#+begin_src lisp
  (define new-variable 42)
#+end_src

~new-variable~ is now a symbol bound in the environment.
It has an integer value of =42=.

You can see the value a symbol has by evaluating it.
#+begin_src lisp
  new-variable
#+end_src
The output will be =42=, as the symbol was evaluated.
Evaluating a symbol means it is replaced with
the corresponding value from the environment.

Sometimes, it is useful to *not* evaluate a variable.
This can be done using the ~QUOTE~ operator.
#+begin_src lisp
  (quote new-variable)
#+end_src

As this is a very common necessity in LISP, there is
a special short-hand for it: a preceding single-quote.
This short-hand means the following to be equivalent to the ~QUOTE~ just above.
#+begin_src lisp
  'new-variable
#+end_src

When defining any variable, it is possible to define
a docstring for it by specifying it as a third argument:
#+begin_src lisp
  (define new-variable 42 "The meaning of life, the universe, and everything.")
#+end_src

The docstring may be accessed using the ~DOCSTRING~ operator, like so:
#+begin_src lisp
  (docstring new-variable)
#+end_src

This allows for everything in LITE LISP to self-document it's use.

*** Lambda

If you are not familiar, a lambda is just a function with no name.

Currently, lambdas have the following syntax:
#+begin_src lisp
  (lambda (ARGUMENT ...) BODY-EXPRESSION)
#+end_src

There is also support for variadic arguments using an /improper list/.
Improper lists have not ~NIL~ at the end, but a value.

The syntax for an improper list is as follows:
: (1 2 3 . 4)

In the context of a lambda, here is how to define
a function with a varying number of arguments.
#+begin_src lisp
  (lambda (argument1 argument2 . the-rest) BODY-EXPRESSION)
#+end_src

After all fixed arguments are given, the rest are
converted to a list and passed to the function.

As a real-world example, here is a factorial implementation in LITE LISP:
#+begin_src lisp
  (define fact (lambda (x) (if (= x 0) 1 (* x (fact (- x 1))))))
#+end_src

The standard library includes a macro to ease the definition of a function: ~DEFUN~.
This macro requires a docstring, so as to encourage best practices.
Here is the factorial example seen just above defined using it.
#+begin_src lisp
  (defun fact (x) "Get the factorial of integer X." (if (= x 0) 1 (* x (fact (- x 1)))))
#+end_src


*** Macros

A macro may be created with the ~MACRO~ operator.
A macro is like a lambda, except it will return the result of evaluating
it's return value, rather than it's return value being the result.
This allows for commands and arguments to be built programatically in LISP.

Macros require a docstring, so as to ensure each one is well-documented.
The docstring may be accessed using the ~DOCSTRING~ operator, like so:
#+begin_src lisp
  (docstring quasiquote)
#+end_src

In order to ease the making of macros, there is /quasiquotation/.
It is similar to quote, but it is possible to unquote specific
pieces so as to evaluate them before calling the built expression.

While it is possible to call the quasiquotation operators
manually, there are short-hand special forms.
- '`'  -- QUASIQUOTE
- ','  -- UNQUOTE
- ',@' -- UNQUOTE-SPLICING

These special forms allow macro definitions to
look more like the expressions they produce.

A simple example that mimics the ~QUOTE~ operator:
#+begin_src lisp
  (macro my-quote (x) "Mimics the 'QUOTE' operator." `(quote ,x))
#+end_src

The QUASIQUOTE special-form at the beginning will cause
the QUOTE symbol to pass through without being evaluated.
The UNQUOTE special-form before the ~X~ symbol will
cause it to be evaluated.

For example, calling ~(my-quote a)~ will expand to ~(QUOTE A)~,
which will result in the symbol ~A~ being returned.
The quasiquotation prevents QUOTE from being evaluated,
but UNQUOTE causes the given expression to be evaluated
(in this case, the argument variable ~x~ evaluates to ~42~).

When including the standard library, ~DEFMACRO~ operates the same as ~MACRO~.

When the environment variable ~DEBUG/MACRO~ is non-nil,
extra output concerning macros is produced.

*** Comments

Comments are delimited with the ';' character, per line.

#+begin_src lisp
  ;; This is a comment
  ;; It begins with a ';', and ends upon encountering a newline.
  (define length 42069) ; They work at the end of lines, as well.
#+end_src

*** Misc

- Environment

  Get the current environment by using the ~ENV~ operator.

  Alternatively, visualize the environment using by
  setting ~DEBUG/ENVIRONMENT~ to any non-nil value.

- Symbol Table

  Get the current symbol table with the ~SYM~ operator.

  Alternatively, visualize the environment using by
  setting ~DEBUG/ENVIRONMENT~ to any non-nil value.

- Closure environment syntax

  Currently, closures are stored in the environment with the following syntax:
  : (ENVIRONMENT (ARGUMENT ...) BODY-EXPRESSION)
